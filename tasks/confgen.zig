//! Rule config generator task. This does two things:
//! 1. Generates the rules config struct from all registered rules.
//! 2. Generates a JSON schema for `zlint.json`.
//!
//! Note that rules config is a subset of zlint's full config.
const std = @import("std");
const gen = @import("gen_utils.zig");
const zlint = @import("zlint");
const c = @import("constants.zig");
const Allocator = std.mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const Schema = zlint.json.Schema;
const Config = zlint.lint.Config;

const fs = std.fs;
const panic = std.debug.panic;

var buf: [1024]u8 = undefined;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var stack = std.heap.stackFallback(256, allocator);
    const stackalloc = stack.get();

    const out = try fs.cwd().createFile(c.@"Rules.zig", .{});
    defer out.close();
    const writer = out.writer(&buf);
    var w = writer.interface;
    defer w.flush() catch @panic("failed to flush writer");

    try w.writeAll(
        \\//! Auto-generated by `tasks/confgen.zig`. Do not edit manually.
        \\const RuleConfig = @import("rule_config.zig").RuleConfig;
        \\const rules = @import("../rules.zig");
        \\
    );

    for (gen.RuleInfo.all_rules) |rule_info| {
        const snake_name = try rule_info.snakeName(stackalloc);
        defer stackalloc.free(snake_name);

        // e.g. homeless_try: RuleConfig(rules.HomelessTry) = .{},
        try w.print(
            "{s}: RuleConfig(rules.{s}) = .{{}},\n",
            .{ snake_name, rule_info.name(.pascale) },
        );
    }
    try createJsonSchema(allocator);
}

fn createJsonSchema(allocator: Allocator) !void {
    var arena = ArenaAllocator.init(allocator);
    defer arena.deinit();
    var ctx = Schema.Context.init(allocator);
    const root = try ctx.genSchema(Config);
    const rules_config: *Schema.Object = &ctx.getSchema(Config.RulesConfig).?.object;

    var source_arena = ArenaAllocator.init(allocator);
    defer arena.deinit();

    const root_dir = std.fs.cwd();
    for (gen.RuleInfo.all_rules) |rule| {
        const alloc = source_arena.allocator();
        defer {
            _ = arena.reset(.retain_capacity);
        }

        std.log.info("Rule: {s}", .{rule.path});
        const source = try gen.readSourceFile(alloc, root_dir, rule.path);
        const rule_docs = try gen.getModuleDocs(source, alloc) orelse panic(
            "Reached EOF on rule '{s}' before finding docs and/or rule impl.",
            .{rule.name(.kebab)},
        );
        const rule_schema = rules_config.properties.getPtr(rule.name(.kebab)).?;
        const copied = try ctx.allocator.dupe(u8, rule_docs);
        var common = rule_schema.common();
        common.description = copied;
        try common.extra_values.put(ctx.allocator, "markdownDescription", .{ .string = copied });
    }

    const schema = try ctx.toJson(root);
    var out = try fs.cwd().createFile(c.@"zlint.schema.json", .{});
    defer out.close();
    try std.json.stringify(schema, .{ .whitespace = .indent_4 }, out.writer());
}
