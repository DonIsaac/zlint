  ğ™­ case-convention: Function ThisFunctionIsInPascalCase name is in PascalCase. It should be camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn ThisFunctionIsInPascalCase() void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function @"this-one-is-in-kebab-case" name is in kebab-case. It should be camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn @"this-one-is-in-kebab-case"() void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function this_one_is_in_snake_case name is in snake_case. It should be camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn this_one_is_in_snake_case() void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function @"This-is-both-Pascal-and-Kebab-kinda" name is not in camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn @"This-is-both-Pascal-and-Kebab-kinda"() void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function This_is_both_snake_case_and_pascal_kinda name is not in camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn This_is_both_snake_case_and_pascal_kinda() void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function This_is_both_snake_case_and_pascal_kinda name is not in camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn This_is_both_snake_case_and_pascal_kinda(a: u32, b: u32, c: u32, d: u32) void {}
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Function 'fooBar' returns a type, but does not use PascalCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn fooBar() type { return u32; }
   Â·    â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€
  help: By convention, Zig uses PascalCase for structs, generics, and all other type variables.

  ğ™­ case-convention: Function NotGeneric name is in PascalCase. It should be camelCase
   â•­â”€[case-convention.zig:1:4]
 1 â”‚ fn NotGeneric(T: type) T { return T{}; }
   Â·    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Type parameter `t` should be in PascalCase
   â•­â”€[case-convention.zig:1:8]
 1 â”‚ fn foo(t: type, x: t) t { return x; }
   Â·        â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Type parameter `t` should be in PascalCase
   â•­â”€[case-convention.zig:1:17]
 1 â”‚ fn foo(comptime t: type, x: T) t { return x; }
   Â·                 â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Parameter `X` should be in lower_snake_case
   â•­â”€[case-convention.zig:1:8]
 1 â”‚ fn foo(X: u32) u32 { return @as(u32, X); }
   Â·        â”€
   â•°â”€â”€â”€â”€

  ğ™­ case-convention: Type parameter `fooBar` should be in PascalCase
   â•­â”€[case-convention.zig:1:8]
 1 â”‚ fn foo(fooBar: type) void { _ = fooBar; }
   Â·        â”€â”€â”€â”€â”€â”€
   â•°â”€â”€â”€â”€

