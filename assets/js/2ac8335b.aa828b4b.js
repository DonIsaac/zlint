"use strict";(self.webpackChunkzlint=self.webpackChunkzlint||[]).push([[7666],{2879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contributing/creating-rules","title":"Creating New Rules","description":"This guide will walk you through creating a new lint rule. For the sake of","source":"@site/docs/contributing/creating-rules.md","sourceDirName":"contributing","slug":"/contributing/creating-rules","permalink":"/docs/contributing/creating-rules","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/contributing/creating-rules.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Contributing","permalink":"/docs/contributing/"},"next":{"title":"Rules","permalink":"/docs/category/rules"}}');var s=t(4848),r=t(8453);const o={},d="Creating New Rules",l={},c=[{value:"Generating Boilerplate",id:"generating-boilerplate",level:2},{value:"Using the AST",id:"using-the-ast",level:2},{value:"Reporting Violations",id:"reporting-violations",level:2},{value:"Testing",id:"testing",level:2}];function a(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"creating-new-rules",children:"Creating New Rules"})}),"\n",(0,s.jsxs)(n.p,{children:["This guide will walk you through creating a new lint rule. For the sake of\nexample, we'll be creating ",(0,s.jsx)(n.a,{href:"https://github.com/DonIsaac/zlint/blob/main/src/linter/rules/no_undefined.zig",children:(0,s.jsx)(n.code,{children:"no-undefined"})}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Make sure you've followed the ",(0,s.jsx)(n.a,{href:"/docs/contributing/",children:"setup guide"})," first."]})}),"\n",(0,s.jsx)(n.h2,{id:"generating-boilerplate",children:"Generating Boilerplate"}),"\n",(0,s.jsxs)(n.p,{children:["Start off by running ",(0,s.jsx)(n.code,{children:"just new-rule <rule-name>"})," to generate boilerplate code."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"just new-rule no-undefined\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will do the following:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a new rule, ",(0,s.jsx)(n.code,{children:"NoUndefined"}),", in ",(0,s.jsx)(n.code,{children:"src/linter/rules/no_undefined.zig"})," with\nmethod and test stubs."]}),"\n",(0,s.jsxs)(n.li,{children:["Register ",(0,s.jsx)(n.code,{children:"NoUndefined"})," to the list of all lint rules by re-exporting it in\n",(0,s.jsx)(n.code,{children:"src/linter/rules.zig"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.code,{children:"no_undefined.zig"}),". It will look something like this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zig",children:'// ... imports omitted\n\nconst NoUndefined = @This();\npub const Name = "no-undefined";\n\npub fn runOnNode(_: *const NoUndefined, wrapper: NodeWrapper, ctx: *LinterContext) void {\n    @panic("TODO: Implement");\n}\n\npub fn runOnSymbol(_: *const NoUndefined, symbol: Symbol.Id, ctx: *LinterContext) void {\n    @panic("TODO: Implement");\n}\n\npub fn rule(self: *NoUndefined) Rule {\n    return Rule.init(self);\n}\n\n// ... tests omitted. We\'ll cover this later.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"runOn*"})," methods provide different ways to check for and report violations.\nThe only difference between them is how they are called. Neither is better or\nworse than the other: just more or less useful for your specific rule."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"runOnNode"})," is called for every node in the AST."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"runOnSymbol"})," is called for every symbol in the symbol table."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Pick the most convenient method for your rule and delete the other(s). Since\n",(0,s.jsx)(n.code,{children:"NoUndefined"})," looks for identifiers named ",(0,s.jsx)(n.code,{children:"undefined"}),", we'll use ",(0,s.jsx)(n.code,{children:"runOnNode"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"using-the-ast",children:"Using the AST"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"[!NOTE]\nWe highly recommend you familiarize yourself with Zig's AST and parser. We'll\ngo over pieces here, but these resources should provide more details."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://ziglang.org/documentation/master/std/#std.zig.Ast",children:[(0,s.jsx)(n.code,{children:"std.zig.Ast"})," API docs"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://mitchellh.com/zig/parser#anatomy-of-an-ast-node",children:"This blog post by Mitchell Hashimoto on Zig's parser"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"NodeWrapper"})," contains the current\n",(0,s.jsx)(n.a,{href:"https://ziglang.org/documentation/master/std/#std.zig.Ast.Node",children:"node"})," as well\nas it's id. We can check the node's\n",(0,s.jsx)(n.a,{href:"https://ziglang.org/documentation/master/std/#std.zig.Ast.Node.Tag",children:"tag"})," to\ndetermine what kind of node it is. In our case, we're looking for ",(0,s.jsx)(n.code,{children:".identifier"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zig",children:'pub fn runOnNode(_: *const NoUndefined, wrapper: NodeWrapper, ctx: *LinterContext) void {\n    const node = wrapper.node;\n    if (node.tag != .identifier) return;\n    @panic("TODO: Implement");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Identifiers don't store their value directly. Instead, we need to look it up\nfrom the source code using the identifier's span, which covers the start and end\nbyte offsets of the identifier and can be used to create a slice."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When you have a node (",(0,s.jsx)(n.code,{children:"Ast.Node.Index"}),"), use ",(0,s.jsx)(n.code,{children:"ast.getNodeSource(id)"})]}),"\n",(0,s.jsxs)(n.li,{children:["When you have a lexer token (",(0,s.jsx)(n.code,{children:"Ast.TokenIndex"}),"), use ",(0,s.jsx)(n.code,{children:"ast.tokenSlice(id)"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Since an identifier node is only a single token "wide", it doesn\'t matter which\nwe use in this case.'}),"\n",(0,s.jsxs)(n.p,{children:["We can get the AST from the ",(0,s.jsx)(n.code,{children:"LintContext"})," parameter. Besides the AST, it also\nstores semantic information obtained from semantic analysis, methods for\nreporting rule violations, and other kinds of helpers. It's really quite\nimportant, so make sure you understand what it provides and how to use it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zig",children:'pub fn runOnNode(_: *const NoUndefined, wrapper: NodeWrapper, ctx: *LinterContext) void {\n    const node = wrapper.node;\n    const ast = ctx.ast();\n\n    if (node.tag != .identifier) return;\n    const identifier = ast.getNodeSource(node.id);\n    if (!std.mem.eql(u8, identifier, "undefined")) return;\n\n    @panic("TODO: Implement"); // TODO: report violations\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"reporting-violations",children:"Reporting Violations"}),"\n",(0,s.jsxs)(n.p,{children:["Lint rule violations, also called diagnostics, are reported using\n",(0,s.jsx)(n.code,{children:"LintContext.diagnostic()"}),". It takes an error message and one or more ranges of\nsource code (i.e a ",(0,s.jsx)(n.code,{children:"Span"}),") that cover problematic parts of code."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zig",children:'pub fn runOnNode(_: *const NoUndefined, wrapper: NodeWrapper, ctx: *LinterContext) void {\n    const node = wrapper.node;\n    const ast = ctx.ast();\n\n    if (node.tag != .identifier) return;\n    const identifier = ast.getNodeSource(node.id);\n    if (!std.mem.eql(u8, identifier, "undefined")) return;\n\n    @panic("TODO: Implement"); // TODO: report violations\n    ctx.diagnostic(\n        "Do not use undefined.",       // error message\n        .{ctx.spanT(node.main_token)}, // covers the identifier lexer token.\n    );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Important notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"diagnostic"})," has several other variants depending on how you want to create\nerror messages. For example, to use a format string, use ",(0,s.jsx)(n.code,{children:"diagnosticFmt"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"spanT"})," creates a span from a lexer token, while ",(0,s.jsx)(n.code,{children:"spanN"})," creates one from a\nnode index. You can also create one directly and pass a ",(0,s.jsx)(n.code,{children:"LabeledSpan"})," instance\nto ",(0,s.jsx)(n.code,{children:"diagnostic"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.p,{children:["When you ran ",(0,s.jsx)(n.code,{children:"just new-rule"}),", a test stub was created at the bottom of your\nfile."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zig",children:'const RuleTester = @import("../tester.zig");\ntest ${StructName} {\n    const t = std.testing;\n\n    var no_undefined = NoUndefined{};\n    var runner = RuleTester.init(t.allocator, no_undefined.rule());\n    defer runner.deinit();\n\n    const pass = &[_][:0]const u8{\n        // TODO: add test cases\n        "const x = 1",\n    };\n\n    const fail = &[_][:0]const u8{\n        // TODO: add test cases\n        "const x = 1",\n    };\n\n    try runner\n        .withPass(pass)\n        .withFail(fail)\n        .run();\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Fill in ",(0,s.jsx)(n.code,{children:"pass"})," and ",(0,s.jsx)(n.code,{children:"fail"})," with snippets of valid Zig source code. ",(0,s.jsx)(n.code,{children:"RuleTester"}),"\nchecks that ",(0,s.jsx)(n.code,{children:"pass"})," cases produce no lint rule violations, and that ",(0,s.jsx)(n.code,{children:"fail"})," cases\nproduce at least one violation. Additionally, snapshots of diagnostics produced\nby ",(0,s.jsx)(n.code,{children:"fail"})," cases will be saved to a snapshot file."]}),"\n",(0,s.jsx)(n.p,{children:"Fill these out, then run the tests."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"just test\n"})}),"\n",(0,s.jsx)(n.p,{children:"Make sure you stage and commit the generated snapshot file."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);